### Day 2300: Process Memory Allocation

When you execute a process in your Linux Operating system, The OS needs to allocated memory to store process information, the main sections of memory allocated are `Text`, `Data`, `Heap` and `Stack`. The Text section is used to store the application machine code, this is your Java, Python, C code compiled to machine code to be executed by the OS. The Data sections is used to store global variables like static non mutable data. The Heap section is used to store dynamic allocated memory when executing the process like using `malloc` in C applications. Finally the Stack section is used to store local variables and return addresses, this is the code that lives inside your code functions. It is interesting how Linux to represent a process divide their data into sections.****

### Day 2297-98-99: Continue Learning C

During the weekend I continue learning more concepts and techniques for the C programming language. I learned about `framing` in network communication. One of the main problems working with a TCP socket is the data/bytes travels as just bytes so you don't in code how to know when a message start or ends. To solve this problem we need to use a framing technique, the most popular are delimiter-based framing and length-prefixed framing. In Delimited-based framing we read bytes from the socket until we receive a byte that is know as the delimiter like the `\n` character, when we found this character we can know that message ends. In `Length-prefixing framing`, we first send a header byte normally an int type, and the value is the bytes that the severs needs to read from the client connection. It is interesting how this techniques works, I did some code C exercises with both techniques and for my surprise both requires much coe to work, rather than sending just a struct and receive the same struct in the server.

### Day 2296: Network Wire Protocol

Today I have been studying how a server and a client application communicates while sending structs/Classes through a socket connection on C. I learned that one of the main problems while working with C and TCP sockets, is how your client send data to the server through the Socket, most of the times you will need to implement a binary protocol and both your serve and client needs to talk the same protocol but sometimes you just want to send a fixed-size bytes through the socket like sending struct/classes on C and C++. This approach is good is like sending Java Objects through a socket, but the problem with C/C++ is that sending structs or classes is more complicated because compilers does not compile the code in the same, maybe your client or server runs on a different architecture, and another issues can happen. Ahh it is interesting how in C you will need to manage all these stuff while in other languages like Java you don't need ot worry about this.

### Day 2295: Continue with `SOCK_STREAM` Sockets

Today I continue learning more about Stream network sockets like TCP. I am understanding that because a socket of this type is just like a byte array, you can have issues if you are reading less data from the client socket and leave some bytes because when the server do another read, it reads old bytes from the socket and you can get corrupted data. I am understanding the powerful of sending and managing raw bytes, through a socket, you can have 100% of control of the bytes, but the main problem here is if you don't have a good design, you will end up with a mess of code or a complicated logic. Learning about how C manage sockets is funny and hard for me. I miss data in `JSON` format.

### Day 2294: Understanding a TCP connection

Today i studied about how works a TCP socket connection in C and Linux. I learned that when you create a `socket` in C and you use the `AF_INET` as domain and`SOCK_STREAM` value as the socket type, you create a TCP socket, you can see a TCP socket like an array in which you can store bytes this array/buffer is saved on the Kernel memory, in one side you have a client writing bytes to that buffer and in the other size you have a server getting the bytes from the buffer, so if the client send 100 bytes, the server can read that 100 bytes in two steps. This was an aha moment for me, working with the Java `Socket` API, we can send Java objects through the connection and we don't need to worry about all this stuff, in Java all these things are simplified.

### Day 2293: Java Library as JAR

Today I was working into debug an issue with a Java JAR library. One of the mai problems that I am facing right now is, to debug the issue, I will need to modify the source for the library, compile the library into a JAR, to finally be tested by another application. This is a time consuming activity because to test I change I will need to do the entire workflow, the library is coupled with the application, so there is no way for the moment to test it without the full application flow.

### Day 2291-92: C Unix Domain Application

During the weekend I have been working on a C server application that creates a TCP socket through a Unix Domain Socket, and a client application that connect to the server to send data through the same socket. It is interesting how in C and Linux you can communicate two processes through a Socket file, for the moment I am learning multiple ways to send the data through the Socket, like sending an `char*` and a `struct`.

### Day 2290: Continue with C

Today I continue doing more C code exercises. I did multiple C exercises like creating pointer, studying C pointers, how to review the memory address of a pointer in Hex values, why the ASCII encoding is very important, etc. I have the plan to learn C for some time while watching a C course, Do code exercises and maybe read a book about C.

### Day 2289: C Size Types & Padding

Today I have been studying about much bytes on size requires the common C types. I am learning about how to calculate the total size of a C struct including their padding value. It is interesting that the Operating system requires that rhe size of a C struct needs to be a multiple of their largest element, for example if a struct contains a `int64_t` element, their size needs to be a multiple of 8, can be 8, 16 , 24, 32, etc. I will need to continue investigating this over the weekend.  

### Day 2288: Sending C Structs by Socket

Today I was learning about how to send a C `struct` through a TCP socket connection, and in the other side the server reads the bytes as a struct also. This technique is called serialization or struct passing, it is interesting because you can send structs and C through the `read` syscall, gives you a struct with data. I will continue exploring more about this technique while doing some code examples or a mini project.

### Day 2287: Portability Issues with C in 32- and 64-bit OS

Today I was working into research about how create code that can be portable. I want to write my C code and works identical in a MacOS or Linux maybe with a Linux running on 32-bit, I discovered that C offers types to allow this like `int8_t`, `int16_t`, `int32_t`, and `int64_t` to represent integer types, there are more types to represent pointers that can be used. I will work into refactor some code to do portable and I want to prevent to write code which this issues.

### Day 2285-86 Continue Working on my new Project

Today I will continue writing the code for my new project. For the moment I am having issues with the C code, when my Java code calls a C function through JNI, this JNI code also calls another C function that opens a client socket to an application that is running on the same machine, the problem is I don't know why my C code is not opening the Client socket and sending the file bytes to the server, so I will need to continue debugging this issue.

### Day 2284 GCC Compiler

Today I study about the most common GCC flags when compiling C code to avoid common issue like warning messages for non good C practices. It is interesting how the C compiler in this case GCC or xlC the ones that I know are vry basic, how do you say you can write C code without a lot of restrictions, like in Go that If you create a variable and is not used, you have a compilation error, on C obviously the types ae checked like any Compiled language, but you have the option to compile your code with good code practices adding flags. I don't know if in another languages/compilers like Java, TypeScript or Go, you can do the same to add flags to improve something in your code.

### Day 2282-83 New Java JNI C Project

Over the weekend I started a Java, JNI and C project. My general idea is to build something like a Distributed Sidecar File Processor project. I want a Java application that works as a CLI client, clients can use the CLI to perform file operations, at this moment I only have the plan to support calculating a checksum for a file. This Java code is just the client and next uses JNI to read the file bytes, open a client TCP socket connection and send the file through the Socket in chunks. On the other side I have a C server that reads these bytes, calculates the checksum to finally return the checksum calculated to my JNI, and sends the checksum to the final Java client. I want to continue learning more about C and JNI and put in practice my new Operating systems knowledge with low level concepts.

### Day 2281: C CPU Experiments

Today I did some C applications to understand better how the CPU works. For example I created a basic C application that write 1 byte into a file 1000000000 if times, in each loop iteration writes just one byte. On this application the CPU spend all the time doing System calls so the CPU is busy just doing that. I learn how to use the `top` linux command to review the CPU statistics like Idle time.

### Day 2280: Pipelining and Parallelism on the CPU

Today I learned that **Pipelining** is a CPU technique used to overlaps stages of an instruction. The main is to have always the CPU busy doing instructions, remember that to execute an instruction we have the following stages: `Fetch, Decode, Execute, Write`. The CPU can be executing instruction 1 in the Decode phase and when start the second phase, the CPu immediately can start to execute the Fetch stage of the instruction 2. When I discover this technique I feel curiosity about when I can implement this technique while writing code and save time, really I don't know about this concept with much detail until learn about the CPU. Parallelism is another technique to maintain busy the CPU, but parallelism is controlled by the developer that wrote the code rather than pipelining that is controlled by default for the CPU. A classic example of parallelism is having an application that split a task into two tasks and then create two threads to execute one task per thread is like multithreading programming.

### Day 2279: Memory Layout, Branch Logic & Data Dependencies

Today while studying about the CPU and how it works, I identified three of the main common problems when we start to have a low performance for an application. The `Memory Layout` is how you organize your code to avoid to have cache misses, remember that a cache miss requires ~300 cycles to retrieve the data from the main memory. If you build your code in way that the related elements are stored side-by-side, this mean when the CPU needs to retrieve one element from the main memory, retrieves a 64-bit chunk and in that chunk the subsequent elements are located, so when the CPU needs to read the next element, it read from Cache. A good `Branch Logic` means that your statements like `if/else` are simple to understand, the CPU uses a technique called branch predictor, so when the CPU found a branch in code, attempts to predict which statement will be execute it and prepare to execute them, but if the CPU predict wrong, the CPU discards the current branch and load the correct. Finally `Data Dependencies` is an issue when your code instruction depends on the previous one, think on this like using the result of an expression into the seconds instruction. Really it is amazing how the CPU works.  

### Day 2278: Continue Learning about the CPU

Today I will continue learning more about how works the CPU. I learned an interesting thing today about CPU cycles, a CPU cycle is like a heartbeat that the CPU does, you think of these cycles like a cycle=instructions, for example to access data from the L1 cache, the CPU requires 3-4 cycles, in computer science it is preferred to measure the performance of an application in CPU cycles because the effort to execute an application in a 1GHz or 3GHz CPU is the same rather than measure the performance on wall-clock time. But I discovered that when the CPU requires to read data from the Main Memory RAM, a 3GHz CPU wait or waste more CPU cycles rather than a 1GHz CPU, yeah this is confuse at the beginning, modern CPU requires much cycles to read data from Main memory. The CPU learning is very interesting, I will continue learning more about the CPU for this week.

### Day 2277: Inside the CPU

Today I continue studying the fundamentals of operating system course, I begin the CPU section in which we study the CPU architecture and the components that build a CPU. I learned about the ALU, CU, Bus and Registers. The Arithmetic Logic Unit is a component that perform arithmetic operations like add, subtract, division, etc but also execute XOR, ADD, etc operations. The Bus is a component that allow the CPU to interact with the Main memory to fetch data. The Registers are components that lives inside the CPU that store bytes for fast access, these registers have a Distributed Shared Memory DSM architecture. Finally the CU is like the brain of the CPU, because it orchestrates the others components to work together to complete the action.

### Day 2276: Back from Vacations

I am back from vacation. I really enjoyed my vacation with my family. During my vacation I took a break from code tasks. I set my 2026 goals as a Software Engineer to know which things I want to focus on this year. I have the goal to focus on the following three fields: Storage Virtualization, Distributed Systems and Backup Storage technologies. I am very excited to deeply study these three fields. Also I configured a Linux server using an old computer. I want to learn more about Linux this year and C programming, I builded a little Linux Kernel module that just prints a hello world as an experiment. So many interesting things for me come in this 2026 year.

### Day 2260-61-62-63: JNI and C Code

During these days I continue learning more about JNI Java framework, how to compile Java and C code using JNI. Also I started a new C project to put in practice all my learned knowledge on C building a Java/JNI/C project.

### Day 2259: Java JNI Issues

Today I learned more about the JNI interface. The Java JNI is used to use C code in Java code, with the JNI you can create a C library to perform X task, and next you can use that library with Java. This JNI library is a little complicated because you will need to compile the Java and C code in a compatible way. I will need to continue learning more about Java JNI.

### Day 2258: Organizing Task as a Software Engineer

I decided to take a break from software engineering for the last two weeks of the 2025 year, I want to use this time to review my completed learning materials, start to do reflections about my 2025 year as a software engineer, organize my pending learning tasks, like books/courses, organize my notes, etc. The next week I will have vacation time from work, so I want to appreciate my last days of 2025 work dates. I have pending to read some non-technical books, this is a good time to read it.

### Day 2257: Back to DSA?

Today I don't know why but I want to try to solve a DSA problem. I attempted to solve the algorithm `Partition Point in the Array
`, this is an easy algorithm and I felt very bad because I could not solve it in the 20 minutes of time that I want to spend. Tomorrow I will need to. continue solving the algorithm, really do DSA more frequently no matters if you are a experience engineer, DSA is a skill that requires continues practicing to avoid forget it or maybe just I am not very smart.

### Day 2255-56: Memory Management

Over the weekend I continue learning more about Operating system Memory Management. I focused in the Direct Memory Access (DMA) feature in an operating system to allow a process to read data from memory faster. The problem when you need to read bytes from a peripheral device like a network card or disk, and if you follow the normal flow `IO Device -> CPU -> Memory` is because the CPU needs to work as a mediator between the Main Memory and the IO Device, and most of the times do nothing with the bytes just pass through. DMA allows you to bypass the CPU mediator, so your process can read bytes from an IO device directly, without the extra CPU step. This is nice design that scale, but this contains some trade-offs like security concerns.

### Day 2254: Distributed Systems Issues

One of the main problems when having a distributed systems is coordination, how you ensure that the processes within the system works in synchronize and how to avoid the happens-before issues, this is one of the main problems with Distributed Systems. I was working today into understand the happens-before events that needs to be executed in the correct order for a distributed system, because if one of this event is not executed in the correct order, the processes communication is lost and a new connection needs to be established.

### Day 2252-2253: Java Object Oriented Programming

Today I learned how you can create software abstractions from hardware components. I was modeling some Java classes to represent hardware components, this was a very interesting exercise to learn how to abstract things. Also I write some `Perl` code, yes Perl code, to create some scripts. Perl looks like an interesting programming language, but one of the main problems that I am facing is Perl contains a lot of abstractions for text manipulation and other things, and you can do much thing with just 3 lines of code.  

### Day 2251: Debugging Code

Today was a hard day, I spend all my date debugging legacy code. Debugging legacy code is a spend task most of the times, when you need to work in a codebase without design, architecture and when the code is poor documented and leak of unit tests. I just can say, good luck when you need to debug legacy codebases.